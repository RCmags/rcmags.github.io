---
layout: post
title: "Render the output of an ADNS-3080 sensor as a grayscale image"

# image sliders:
slider1:
- url: https://raw.githubusercontent.com/RCmags/ADNS3080_frame_capture/main/images/car.png
- url: https://raw.githubusercontent.com/RCmags/ADNS3080_frame_capture/main/images/hand.png
- url: https://raw.githubusercontent.com/RCmags/ADNS3080_frame_capture/main/images/ruler.png
---

While working on a library to decode the signal from an [ADNS 3080 mouse sensor](https://github.com/RCmags/ADNS3080), I had to develop a system to visualize the image of the camera inside the sensor. This was critical as without being able to see the image, it was very difficult to focus the camera's lens to get the best possible motion tracking. While the sensor did have a output SQUAL output, which was a measure of the quality of the surface being measured, it wasn't entirely accurate and varied a lot with the surface and illumination. Therefore, its value depended on other variables besides the focus of the camera. 

![image](/img/mouse-sensor/focus-length.png)
<p align="center"><i>Cameras make the best image when objects are in focus</i></p>

I chose to use [Python](https://www.python.org/) to render the image as it contains many libraries that make it easy to convert the data from the Arduino to a display on a computer. Since the serial data from the camera came in as an array it was necessary to decompose the array into two dimensions to generate an image. This was done by using the [TkInter](https://wiki.python.org/moin/TkInter) library to generate a grid of boxes whose color could be changed. Each box could range from being white to black and any gray color in between. A drawback of this system is high computational load. Since the array is being decomposed into two sections, I employed two nested [for loops](https://wiki.python.org/moin/ForLoop) within which the TKinter elements were being modified. Python is known to be very slow when dealing with for loops, so the refresh rate of the images was very slow. The Python script also worked in conjunction with an [Arduino](https://www.arduino.cc/) script which returned the readings of the sensor via a serial port. Both files worked in conjunction and needed to have the same __baud rate__ and __begin character__. This last value controlled when the python script started and stopped receiving information from the arduino. The arduino took the readings from the sensor and flattened them into an array. 

When the program sent the _begin character_, a new position in the y-axis was specified and the x-axis was scanned for that position. The fact that the data was being sent character by character via the serial port, in addition to the slow double four loop in the Python script, meant that the entire image rendering was very slow. Due to the lag this system was not well suited to looking at the camera in real time. Despite this limitation, the system worked well enough to focus the lens when looking at a fixed image. A properly focused camera should generate these kinds of images:

{% include image-slider.html list=page.slider1 local='yes' aspect_ratio='1/1' %}
<p align="center"><i>Snapshots from the low-resolution camera</i></p>

### Github Repo:
The repository contains a python script and an arduino sketch to render the output of an ADNS3080 mouse sensor as a grayscale image. The script was written in __python 3__ and requires the [pyserial library](https://pythonhosted.org/pyserial/pyserial.html#overview). The arduino sketch makes use of the [ADNS3080 library](https://github.com/RCmags/ADNS3080). Credit goes to [Lauszus](https://github.com/Lauszus/ADNS3080) for the inspiration as the script is largely based on his work. 

See: [ADNS3080_frame_capture](https://github.com/RCmags/ADNS3080_frame_capture)

